{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "4ba59abb",
   "metadata": {},
   "source": [
    "# ★ MNIST Handwritten Digits Recognition ★\n",
    "Domain: Computer Vision / Deep Learning\n",
    "Objective: Classification of handwritten digits (0-9) using neural networks\n",
    "Dataset: MNIST (60,000 train samples, 10,000 test samples)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9d263c14",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 1. Importing Libraries\n",
    "import math\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "plt.rcParams['figure.figsize'] = [10,6]\n",
    "\n",
    "import tensorflow as tf\n",
    "import tensorflow_datasets as tfds\n",
    "\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "pd.set_option('display.max_columns', 50)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e58a5767",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 2. Loading MNIST Dataset\n",
    "(ds_train, ds_test), ds_info = tfds.load(\n",
    "    'mnist',\n",
    "    split=['train', 'test'],\n",
    "    shuffle_files=True,\n",
    "    as_supervised=True,\n",
    "    with_info=True\n",
    ")\n",
    "\n",
    "print(f\"Training samples: {ds_info.splits['train'].num_examples}\")\n",
    "print(f\"Testing samples: {ds_info.splits['test'].num_examples}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "07a3f2b0",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 3. Data Exploration\n",
    "n_samples = 50\n",
    "x = np.concatenate([x for x, y in ds_train.take(n_samples)], axis=0)\n",
    "y = [y.numpy() for x, y in ds_train.take(n_samples)]\n",
    "\n",
    "plt.figure(figsize=[20,10])\n",
    "for idx, img in enumerate(x.reshape(n_samples,28,28,1)):\n",
    "    plt.subplot(math.ceil(n_samples/10),10,idx+1)\n",
    "    plt.title(f\"Label: {y[idx]}\", fontsize=8)\n",
    "    plt.imshow(img, cmap='gray')\n",
    "    plt.axis('off')\n",
    "plt.show()\n",
    "\n",
    "labels_train = [y.numpy() for x, y in ds_train]\n",
    "sns.countplot(labels_train)\n",
    "plt.title(\"MNIST Training Label Distribution\")\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "418b1ab0",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 4. Data Preprocessing\n",
    "def normalize_image(image, label):\n",
    "    return tf.cast(image, tf.float32) / 255.0, label\n",
    "\n",
    "ds_train = ds_train.map(normalize_image, num_parallel_calls=tf.data.AUTOTUNE)\n",
    "ds_train = ds_train.cache()\n",
    "ds_train = ds_train.shuffle(ds_info.splits['train'].num_examples)\n",
    "ds_train = ds_train.batch(128)\n",
    "ds_train = ds_train.prefetch(tf.data.AUTOTUNE)\n",
    "\n",
    "ds_test = ds_test.map(normalize_image, num_parallel_calls=tf.data.AUTOTUNE)\n",
    "ds_test = ds_test.batch(128)\n",
    "ds_test = ds_test.cache()\n",
    "ds_test = ds_test.prefetch(tf.data.AUTOTUNE)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "85b9cf4c",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 5. Model Architecture\n",
    "model = tf.keras.models.Sequential([\n",
    "    tf.keras.layers.Reshape(target_shape=(28,28,1), input_shape=(28,28)),\n",
    "    tf.keras.layers.Conv2D(32, kernel_size=(3,3), activation='relu', padding='same'),\n",
    "    tf.keras.layers.MaxPooling2D(pool_size=(2,2)),\n",
    "    tf.keras.layers.Conv2D(64, kernel_size=(3,3), activation='relu', padding='same'),\n",
    "    tf.keras.layers.MaxPooling2D(pool_size=(2,2)),\n",
    "    tf.keras.layers.Flatten(),\n",
    "    tf.keras.layers.Dense(128, activation='relu'),\n",
    "    tf.keras.layers.Dropout(0.3),\n",
    "    tf.keras.layers.Dense(10, activation='softmax')\n",
    "])\n",
    "\n",
    "model.compile(\n",
    "    optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),\n",
    "    loss='sparse_categorical_crossentropy',\n",
    "    metrics=['sparse_categorical_accuracy']\n",
    ")\n",
    "\n",
    "model.summary()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5e9f205a",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 6. Training the Model\n",
    "epochs = 25\n",
    "history = model.fit(\n",
    "    ds_train,\n",
    "    epochs=epochs,\n",
    "    validation_data=ds_test,\n",
    "    verbose=2\n",
    ")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1c35ddbf",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 7. Performance Visualization\n",
    "train_acc = history.history['sparse_categorical_accuracy']\n",
    "val_acc = history.history['val_sparse_categorical_accuracy']\n",
    "train_loss = history.history['loss']\n",
    "val_loss = history.history['val_loss']\n",
    "\n",
    "epochs_range = range(1, epochs+1)\n",
    "plt.figure(figsize=[15,5])\n",
    "\n",
    "plt.subplot(1,2,1)\n",
    "plt.plot(epochs_range, train_loss, 'g', label='Training Loss')\n",
    "plt.plot(epochs_range, val_loss, 'b', label='Validation Loss')\n",
    "plt.title(\"Training and Validation Loss\")\n",
    "plt.xlabel(\"Epochs\")\n",
    "plt.ylabel(\"Loss\")\n",
    "plt.legend()\n",
    "\n",
    "plt.subplot(1,2,2)\n",
    "plt.plot(epochs_range, train_acc, 'g', label='Training Accuracy')\n",
    "plt.plot(epochs_range, val_acc, 'b', label='Validation Accuracy')\n",
    "plt.title(\"Training and Validation Accuracy\")\n",
    "plt.xlabel(\"Epochs\")\n",
    "plt.ylabel(\"Accuracy\")\n",
    "plt.legend()\n",
    "plt.show()\n"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
